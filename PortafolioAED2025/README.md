

# Portafolio de AED - Alfonso Rodriguez

![](https://img.shields.io/github/stars/pandao/editor.md.svg) ![](https://img.shields.io/github/forks/pandao/editor.md.svg) ![](https://img.shields.io/github/tag/pandao/editor.md.svg) ![](https://img.shields.io/github/release/pandao/editor.md.svg) ![](https://img.shields.io/github/issues/pandao/editor.md.svg) ![](https://img.shields.io/bower/v/editor.md.svg)


**Contenido del Portafolio**

[TOCM]



#UT1 - Introducción a Java
La UT1 se concentra para proporcionar una introducción al lenguaje de programación Java y familiarizar los conceptos básicos de la programación orientada a objetos. A través de este módulo, aprendimos la sintaxis y las estructuras fundamentales de Java, como variables, operadores, estructuras de control (condicionales, bucles), y tipos de datos. Tambien se explorarán las clases y objetos. La UT1 también incluye una introducción a los conceptos de compilación y ejecución en Java, y a las herramientas básicas de desarrollo, como el uso de entornos de desarrollo integrados (IDE). El objetivo principal de este módulo es ofrecer una base sólida para comenzar a escribir programas en Java y resolver problemas utilizando este lenguaje.

#UT3 - Listas, Pilas y Colas
En la UT3, se abordan las estructuras de datos fundamentales: listas, pilas y colas. El objetivo de este módulo fue enseñar cómo estas estructuras permiten organizar y gestionar datos de manera eficiente en distintos escenarios. Se profundiza en la implementación y las operaciones básicas de cada una de estas estructuras, tales como inserción, eliminación y búsqueda. Las listas, tanto simples como dobles, se analizaron en detalle las variantes como la LinkedList y la ArrayList para entender sus diferencias en términos de rendimiento y uso adecuado. En cuanto a las pilas y colas, se discutieron los principios de funcionamiento (LIFO para pilas y FIFO para colas) y cómo se utilizan para resolver problemas de programación como el manejo de tareas pendientes o la reversión de secuencias. Además, se profundizo en el análisis de algoritmos y en la complejidad temporal de las operaciones de estas estructuras. Finalmente, se usaron los TDA (Tipos Abstractos de Datos), y cómo las colecciones en Java que facilitan el trabajo con estas estructuras, así como la importancia de elegir la representación adecuada según las necesidades del problema.

#UT4 - Árboles Binarios 
En la UT4, se introduce el concepto de árboles binarios, una estructura de datos jerárquica fundamental en informática. El objetivo de este módulo fue enseñar los fundamentos de los árboles binarios, así como sus aplicaciones en la resolución de problemas, incluyendo búsquedas, ordenación y expresión de datos. Se estudio las diferentes operaciones que pueden realizarse sobre un árbol binario, como la inserción, eliminación, recorrido (inorden, preorden, postorden) y búsqueda. Además de profundizar en los algoritmos de recorrido y en cómo optimizar estas operaciones según la naturaleza del problema. La UT también tuvo hizo hincapié sobre el balanceo de árboles y su importancia en la eficiencia de las operaciones.

#UT5 - Árboles Genéricos
La UT5 se enfoco en los árboles genéricos, que son estructuras de datos más flexibles que los árboles binarios. A través de este módulo, se demostró cómo los árboles genéricos pueden ser utilizados para representar relaciones jerárquicas de forma más general, sin la restricción de tener solo dos hijos por nodo. Se estudio cómo se pueden aplicar en diversas áreas, como bases de datos, sistemas de archivos y modelado de estructuras complejas. Además, se programo las operaciones comunes para trabajar con estos árboles, como inserción, eliminación, recorrido y optimización de algoritmos. Además quedo demostrado al utilidad de cada arbol y su desempeño.

#UT6 - Diccionarios, Mapas y Hashing
En la UT6, se abordo el concepto de diccionarios y mapas, estructuras de datos que permiten almacenar pares clave-valor, facilitando el acceso rápido a la información. Este módulo profundiza en cómo utilizar estas estructuras para resolver problemas complejos de almacenamiento y búsqueda eficiente. Además, se uso las técnicas de hashing, que permiten asignar claves a valores de manera rápida y eficiente, minimizando las colisiones. Se trato temas como las funciones hash, tablas de dispersión (hash tables), y cómo manejar conflictos de colisión (como la resolución por encadenamiento).

#UT7 - Grafos Dirigidos
La UT7 fue el estudio de los grafos dirigidos, que son estructuras de datos fundamentales en la representación de relaciones y dependencias unidireccionales. En este módulo, dio a representar y trabajar con grafos dirigidos, en los que las aristas tienen una dirección específica. Se analizaron diversos algoritmos que operan sobre grafos dirigidos, tales como los algoritmos de búsqueda en profundidad (DFS) y búsqueda en amplitud (BFS), así como el cálculo de caminos más cortos. Además de abordar aplicaciones clave de los grafos dirigidos, como la representación de flujos de trabajo, análisis de redes sociales, redes de transporte y sistemas de recomendación. Se enfatizará también la importancia de los ciclos y la detección de ciclos en grafos dirigidos.

#UT8 - Grafos No Dirigidos
La UT8 se enfoca en los grafos no dirigidos, en los cuales las aristas no tienen una dirección específica, lo que representa una relación bidireccional. Este módulo cubrirá la teoría y las aplicaciones de los grafos no dirigidos, explorando su uso en áreas como la topología de redes, problemas de conectividad, y modelos de relaciones simétricas. Se estudiarán técnicas como la búsqueda en profundidad (DFS) y la búsqueda en amplitud (BFS) aplicadas a grafos no dirigidos, así como algoritmos clásicos para encontrar componentes conexos y detectar ciclos. Además, se abordarán los algoritmos de menor costo, como el algoritmo de Prim y Kruskal, para encontrar árboles de expansión mínima. A través de ejemplos prácticos, los estudiantes comprenderán cómo resolver problemas relacionados con redes de comunicación, rutas de viaje, y análisis de conectividad entre entidades..

#UT9 - Colecciones
En la UT9, se dio el tema de colecciones como estructuras de datos fundamentales para organizar y manipular grandes cantidades de elementos de manera eficiente. Este módulo profundizó en las distintas clases de colecciones disponibles en lenguajes de JAVA, y cómo estas pueden ser utilizadas para resolver problemas prácticos. Además, se estudio las diversas operaciones de ordenación, fundamentales para el manejo eficiente de datos dentro de las colecciones. Se cubrieron los algoritmos clásicos de ordenación como Bubble Sort, Quick Sort y Selección Directa, y más, destacando sus características, ventajas y desventajas en términos de complejidad temporal y rendimiento. El módulo también abarcó el uso de árboles binarios y ejemplos en tablas, estructurando la información en jerarquías y redes. Se profundizó en cómo elegir el tipo adecuado de colección dependiendo del problema a resolver, optimizando tanto el tiempo de acceso a los elementos como las operaciones de búsqueda y modificación. Se discutieron casos prácticos donde estas colecciones y algoritmos son esenciales para resolver problemas en áreas como la gestión de datos y estructuras de árboles.





###Bibliografia
                    

| Libro / Fuente  | Capítulo / Tema | Página / Dirección |  
| ------------- | ------------- | ------------- |  
| Estructuras de Datos y Algoritmos, Aho, Hopcroft, Ullman | Capítulo 8, Secciones 8.1 a 8.5 | - |  
| Estructuras de Datos en Java, Mark Allen Weiss | Cap. 8 "Algoritmos de Ordenación", Secciones 8.1, 8.2, 8.3, 8.4, 8.6.1 a 8.6.7 | - |  
| Introduction to Algorithms, Thomas Cormen | Cap. 9 "Sorting in Linear Time", Sección 9.2 | - |  
| The Algorithm Design Manual, Steven Skiena | Cap. 4 "Sorting and Searching", Secciones 4.1 a 4.8 | - |  
| Estructuras de Datos en Java, Mark Allen Weiss | Cap. 14 "Grafos y Caminos", Secciones 14.1, 14.2, 14.3, 14.5, 14.5.1 | - |  
| The Algorithm Design Manual, Steven Skiena | Cap. 5 "Graph Traversal", Secciones 5.1, 5.2, 5.5, 5.10.1 | - |  
| Pensando la Computación como un Científico | Capítulos 14, 15, 16 (varias secciones) | 193 - 229 |  
| Ordenamiento: Inserción directa | [Wikipedia en inglés](http://en.wikipedia.org/wiki/Insertion_sort) | [Wikipedia en español](http://es.wikipedia.org/wiki/Ordenamiento_por_inserci%C3%B3n) |  
| Ordenamiento: Quicksort | [CSAnimated](http://www.csanimated.com/animation.php?t=Quicksort) | [Algolist](http://www.algolist.net/Algorithms/Sorting/Quicksort) |  
| Heapsort | [Sorting-Algorithms](http://www.sorting-algorithms.com/heap-sort) | [Wikipedia ](http://en.wikipedia.org/wiki/Heapsort) |  
| Estándares de codificación Java | Artículo "Java Code Conventions" | [Enlace oficial](https://www.oracle.com/java/technologies/javase/codeconventions-contents.html) |  
| Tipos de Datos Abstractos: Listas | [Listas - Wikipedia](http://es.wikipedia.org/wiki/Tipo_de_dato_abstracto) | - |  

                    
###Uso de librerias de JAVA
                    

| Nombre | Descripción                    |
| ------------- | ------------------------------ |
| `Queue`      | Estructura de datos que sigue el principio FIFO (First In, First Out).      |
| `Stack`   | Estructura de datos que sigue el principio LIFO (Last In, First Out). |
| `LinkedList`   | Lista enlazada donde cada elemento apunta al siguiente, permitiendo inserciones y eliminaciones eficientes.     |
| `ArrayList`   | Estructura de datos que implementa una lista dinámica basada en arrays, permitiendo acceso rápido por índice y almacenamiento dinámico.|
| `HashMap`   | Estructura de datos que implementa un mapa basado en claves y valores, utilizando una función hash para organizar las entradas. Se usa comúnmente en Java a través de la clase HashMap, que permite acceso rápido a los valores mediante las claves.|
| `HashSet`   | Estructura que implementa un conjunto basado en un hash, donde no se permiten elementos duplicados. Implementado en Java a través de la clase HashSet de la colección java.util.|
| `TreeMap`   | Implementación de un mapa que mantiene las claves ordenadas. En Java, se implementa con la clase TreeMap, que implementa la interfaz NavigableMap.|
| `TreeSet`   | Conjunto basado en un árbol binario que mantiene sus elementos ordenados. En Java, implementado con la clase TreeSet, que es parte de la colección java.util.|
| `Collections`   |Clase de utilidad que proporciona métodos estáticos para trabajar con colecciones, como ordenar, buscar o invertir listas. Utiliza la interfaz List y las implementaciones más comunes como ArrayList y LinkedList.|
| `Comparator`   | Interfaz funcional usada para definir el criterio de ordenación personalizado en colecciones. Se utiliza en conjunto con clases como TreeSet y PriorityQueue para ordenar elementos según un criterio específico.|
| `Arrays`   | 	Clase de colección que implementa tanto la interfaz List como Deque, útil para listas enlazadas y pilas/colas. Proporciona una eficiente inserción y eliminación en ambos extremos.|
| `Hashing`   | Estructura de datos que implementa una lista dinámica basada en arrays, permitiendo acceso rápido por índice y almacenamiento dinámico.|
| `Map`   | Es una interfaz que define una colección de claves y valores. Permite insertar, eliminar y obtener valores asociados a claves. Algunas de sus implementaciones más comunes son HashMap, TreeMap y LinkedHashMap.|
| `LinkedHashMap`   | Es una implementación de Map similar a HashMap, pero mantiene el orden de inserción (o el orden de acceso si se configura así), lo que puede ser útil cuando es importante preservar el orden de los elementos.|

###  UT - Unidades de Trabajo 

- [x] UT-1
- [x] UT-2
- [x]  UT-3
- [x] UT-4
- [x] UT-5
- [x] UT-6
- [x] UT-7
- [x] UT-8
- [x] UT-9